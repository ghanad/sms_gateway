services:
  # --------------------------------------------------------------------------
  #  Server A (FastAPI Gateway) and its Dependencies
  # --------------------------------------------------------------------------
  server-a:
    build:
      context: ./server-a
      dockerfile: Dockerfile
    env_file:
      - ./server-a/.env
    ports:
      - "8001:8000"
    depends_on:
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy

  redis:
    image: "redis:7-alpine"
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - ./redis-data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  rabbitmq:
    image: "rabbitmq:3-management-alpine"
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 10s
      timeout: 5s
      retries: 5

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: smsgw
    ports:
      - "5432:5432"
    volumes:
      - ./pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --------------------------------------------------------------------------
  #  Server B (Django Backend) and its Worker Services
  # --------------------------------------------------------------------------

  # Step 1: A dedicated, short-lived service just for running migrations.
  # The other services will wait for this to complete successfully.
  migration-b:
    build:
      context: ./server-b
      dockerfile: Dockerfile
    command: python manage.py migrate --noinput
    env_file:
      - ./server-b/.env
    depends_on:
      postgres:
        condition: service_healthy

  # Step 2: The main Django web server (Gunicorn).
  # Starts only after migrations are done.
  server-b:
    build:
      context: ./server-b
      dockerfile: Dockerfile
    command: gunicorn --bind 0.0.0.0:9000 sms_gateway_project.wsgi:application
    env_file:
      - ./server-b/.env
    ports:
      - "9000:9000"
    depends_on:
      migration-b:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy

  # Step 3: The Celery worker service for background tasks.
  # Also waits for migrations to be done.
  celery-worker-b:
    build:
      context: ./server-b
      dockerfile: Dockerfile
    command: celery -A sms_gateway_project worker -l info
    env_file:
      - ./server-b/.env
    depends_on:
      migration-b:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy

  # Step 4: The Celery Beat scheduler for periodic tasks.
  # Also waits for migrations to be done.
  celery-beat-b:
    build:
      context: ./server-b
      dockerfile: Dockerfile
    command: celery -A sms_gateway_project beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    env_file:
      - ./server-b/.env
    depends_on:
      migration-b:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy

  # Step 5: RabbitMQ consumer service for outbound SMS.
  sms-consumer-b:
    build:
      context: ./server-b
      dockerfile: Dockerfile
    command: python manage.py consume_sms_queue
    env_file:
      - ./server-b/.env
    depends_on:
      migration-b:
        condition: service_completed_successfully
      rabbitmq:
        condition: service_healthy
      postgres:
        condition: service_healthy
